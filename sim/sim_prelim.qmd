---
title: "bayesRCM Initial Simulation"
author: "Q"
format: 
  html:
    toc: true
    toc-depth: 2
  pdf:
    toc: true
    toc-depth: 2
header-includes:
   \usepackage{float}
   \floatplacement{figure}{H}
---

```{r include = FALSE, error = FALSE, message = FALSE, warning = FALSE}
library(tidyverse)
library(gt)
library(MASS)
library(Rcpp)
library(RcppArmadillo)
library(glasso)
library(GIGrvg)
library(bayesRCM)
library(igraph)
library(ggraph)
library(brainconn)
library(tidygraph)
#library(doParallel)
#library(Matrix)

#Controlling figure output in markdown, setting options & root dir
knitr::opts_chunk$set(
#  fig.height =   
  fig.width = 6,
#  fig.asp = .5,
  out.width = "90%",
#  out.height = 
 fig.align = "center",
  cache = FALSE,
  echo  = TRUE,
  root.dir = rprojroot::find_package_root_file() #not working?
)

#My Colours (from viridis)
my_purple <- "#440154FF"
my_yellow <- "#FDE725FF"
#Set Theme for ggplot2
theme_set(theme_minimal() + 
          theme(plot.title = element_text(hjust = 0.5),
                plot.subtitle = element_text(hjust = 0.5),
                legend.position = "bottom",
                plot.background  = element_rect(fill = "white", colour = "white")
                )
          )
#Set Scientific notation output for knitr
options(scipen = 999)
```

# 1. Generate some data  

```{r sim_data}
#Set parameters
sub   <- 20
vol   <- 250
p     <- 10
a_tau <- sub
lam_2 <- sub / 50  
prop  <- 1/5
nf    <- 1

#Simulate data
sim_res <- sim_data(subjects = sub, volumes = vol, rois = p, alpha_tau = a_tau,
                    lambda_2 = lam_2, prop_true_con = prop, n_flip = nf, write = FALSE, seed = 4)

#Name for directory to store figs
lam_2 <- str_replace(as.character(lam_2), "[.]", "-")
name  <- str_c("sub", sub, "_vol", vol, "_atau", a_tau, "_lam")
```


# 2. Fit the model  

```{r rcm_fit, eval = FALSE}
result <- rcm(sim_res$data_list, n_samples = 2500, n_burn = 500, n_cores = 4, n_updates = 5)
```

```{r}
result <- read_rds("./result.rds")
```

# 3. Analyze results  

## 3.1 $\Omega_0$  

```{r omega_0_res}
n_iter <- ncol(result$omega_0)
set.seed(4)
samp  <- sample(1:nrow(result$omega_0), 25, replace = FALSE)

#Thin the chain
thin_result <- result$omega_0[,seq(1, n_iter, by = 2)]
n_iter <- ncol(thin_result)

#Diagnostics
chain0.gg <- 
  result$omega_0 %>%
  #thin_result %>%
  as.data.frame() %>%
  slice(samp) %>%
  rename_with(
    .cols = everything(),
    ~str_remove(.x, "V")
  ) %>%
  mutate(
    upper_tri = 1:nrow(.)
  ) %>%
  pivot_longer(
    cols = -upper_tri,
    names_to = "iteration",
    values_to = "value"
  ) %>%
  as_tibble() %>%
  ggplot(aes(x = as.numeric(iteration), y = value, colour = upper_tri, group = upper_tri)) +
  #geom_point(size = 0.8, alpha = 0.6) +
  geom_line(size = 0.6, alpha = 0.6) +
  facet_wrap(~upper_tri, scales = "free_y", ncol = 5) +
  theme(legend.position = "none") +
  scale_colour_viridis_c(option = "mako") +
  labs(
    x = "Iteration",
    y = "Value",
    title = "Group Network Posterior MCMC Chain by Connection"
  ) +
  #scale_x_continuous(breaks = seq(0, n_iter, by = floor(1/4*n_iter))) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.5))

#Posterior density GG
#Diagnostics
post_density.gg <- 
#  result$omega_0 %>%
  thin_result %>%
  as.data.frame() %>%
  slice(samp) %>%
  rename_with(
    .cols = everything(),
    ~str_remove(.x, "V")
  ) %>%
  mutate(
    upper_tri = 1:nrow(.) %>% as.factor()
  ) %>%
  pivot_longer(
    cols = -upper_tri,
    names_to = "iteration",
    values_to = "value"
  ) %>%
  mutate(
    upper_tri = as.factor(upper_tri) %>% fct_reorder(value, mean, .desc = TRUE)
  ) %>%
  ggplot(aes(x = value, y = ..density.., fill = upper_tri, colour = upper_tri)) +
  geom_histogram(alpha = 0.4) +
  geom_density(alpha = 0.6, colour = "black") + 
  #geom_point(size = 0.8, alpha = 0.6) +
  #geom_line(size = 0.6, alpha = 0.8) +
  facet_wrap(~upper_tri, scales = "free", ncol = 5) +
  theme(legend.position = "none") +
  scale_colour_viridis_d(option = "mako") +
  scale_fill_viridis_d(option = "mako") +
  labs(
    x = "MCMC Sampled Value",
    y = "Density",
    title = "Group Network Posterior Density by Connection"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.5))
  #stat_summary(aes(y = value), fun = mean, geom = "point", size = 6, shape = "|") 

#Acceptance
accept0.gg <- 
  tibble(
    x = result$omega_acc
  ) %>%
  ggplot(aes(x = x)) +
  geom_density(colour = "black", fill = my_purple, alpha = 0.2) +
  scale_x_continuous(labels = scales::percent) +
  labs(
    x = "Percent Off-Diagonal Acceptance (MH-step)",
    y = "Density",
    title = "Group Network Acceptance Rate by Connection"
  )

```

```{r omega_0_viz, fig.height = 6, fig.width = 5}
#Display Chain
chain0.gg

#Display
post_density.gg
```

```{r omega0_acceptance}
#Display acceptance
accept0.gg
```

```{r post_est_diag, warning = FALSE}
##Precision/Omega
#Take posterior mean/mode as estimates
post_mean  <- apply(result$omega_0, 1, mean)   #L2
post_med   <- apply(result$omega_0, 1, median) #L1

#Lambda 2 Post mean
print("Lambdas post. mean:")
result$lambdas %>% 
  apply(., 1, mean)

#post_mode  <- apply(result$omega_0, 1, stat_mode) # Need a user defined mode func if so
Omega_0    <- sim_res$true_params$omega_0
Sigma_0    <- sim_res$true_params$omega_0 %>% solve()
omega_true <- Omega_0[upper.tri(Omega_0, diag = TRUE)]

#Mean absolute error - raw difference
#map(.x = list(post_mean, post_med), ~summary(.x - omega_true))
#map(.x = list(post_mean, post_med), ~max(abs(.x - omega_true)))

##Variance/Sigma
post_omega0 <- Omega_0 #Just for correct size, going to overwrite
post_omega0[upper.tri(post_omega0, diag = TRUE)]  <- post_mean
post_omega0 <- as.matrix(Matrix::forceSymmetric(post_omega0, uplo = "U"))

post_sigma0 <- solve(post_omega0) #Sigma posterior est.
sigma0_est  <- post_sigma0[upper.tri(post_sigma0, diag = TRUE)]
sigma_true  <- Sigma_0[upper.tri(Sigma_0, diag = TRUE)]

#Summarise difference/error
#summary(sigma0_est - sigma_true)

#Summarise difference in norms (L1, Inf, Frobenius, Spectral) - comparison 
norm_types <- c("1", "F", "2")
post_sigma0_norms <- map_dbl(.x = norm_types, ~norm(post_sigma0, type = .x))
post_omega0_norms <- map_dbl(.x = norm_types, ~norm(post_omega0, type = .x))
sigma_true_norms  <- map_dbl(.x = norm_types, ~norm(Sigma_0, type = .x))
omega_true_norms  <- map_dbl(.x = norm_types, ~norm(Omega_0, type = .x))

#Display Norm results
omega0.gt <-
tibble(
  `Norm Type`   = str_c(c("L1", "Frobenius", "Spectral"), " Norm"),
  # `Sigma Est.`  = post_sigma0_norms,
  # `Sigma Truth` = sigma_true_norms,
  # `Sigma Diff.` = map_dbl(.x = norm_types, ~norm(post_sigma0 - Sigma_0, type = .x)),
  `Omega0 Est.`  = post_omega0_norms,
  `Omega0 Truth` = omega_true_norms,
  `Omega0 Diff.` = map_dbl(.x = norm_types, ~norm(post_omega0 - Omega_0, type = .x))
) %>%
  arrange(`Omega0 Diff.`) %>%
  #group_by(`Norm Type`) %>%
  gt() %>%
  gtExtras::gt_color_rows(contains("Omega0"), palette = "ggsci::blue_material") %>%
  tab_header(
    title = md("**Omega0 Posterior Mean Diagnoistics**"),
    subtitle = "Truth - Post. Mean"
  ) %>%
  cols_align(align = "center") %>%
  tab_style(
    style = list(
      cell_fill(color = "white"),
      cell_text(weight = "bold")
    ),
    locations = cells_body(
      columns = c(`Norm Type`),
      rows    = 1:3 
    )
  ) 
```


## 3.2 $\tau_k$  

```{r tauk_diag, eval = TRUE, echo = FALSE}
#Read in result to display diagnostics
#result <- read_rds("../results/2023_02_13_debug_tauk.RDS")
n_iter <- ncol(result$tau_k)
set.seed(4)

#Diagnostics
#Tauk
tauk.gg <-
  t(result$tau_k) %>%
  as.data.frame() %>%
  mutate(
    iteration = 1:nrow(.)
  ) %>%
  rename_with(
    .cols = -iteration,
    ~str_replace(.x, "V", "Sub. ")
  ) %>%
  pivot_longer(
    cols = -iteration,
    names_to = "tau",
    values_to = "value"
  ) %>%
  mutate(
    tau = as.factor(tau) %>% fct_reorder(value, mean, .desc = TRUE)
  ) %>%
  ggplot(aes(x = iteration, y = value, colour = tau)) +
  #geom_point(size = 0.8, alpha = 0.6) +
  geom_line(size = 0.6, alpha = 0.6) +
  facet_wrap(~tau, scales = "free_y", nrow = 5) +
  scale_x_continuous(breaks = seq(0, n_iter, by = floor(1/4*n_iter)), 
                     minor_breaks = seq(0, n_iter, by = floor(1/4*n_iter))) +
  theme(legend.position = "none") +
  scale_colour_viridis_d(option = "mako") +
  labs(
    x = "Iteration",
    y = "Value",
    title = "Subject-specific Regularizaiton Posterior Samples"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.5))

#Tau_k acceptance
tauk_acc.gg <-
result$tau_acc %>%
  as.data.frame() %>%
  mutate(
    iteration = 1:nrow(.)
  ) %>%
  rename_with(
    .cols = -iteration,
    ~str_replace(.x, "V", "Sub. ")
  ) %>%
  pivot_longer(
    cols = -iteration,
    names_to = "tau",
    values_to = "value"
  ) %>%
  group_by(tau) %>%
  summarise(pct_acc = mean(value)) %>%
  ungroup() %>%
  mutate(
    tau = as.factor(tau) %>% fct_reorder(pct_acc, .desc = FALSE)
  ) %>%
  arrange(tau) %>%
  ggplot(aes(x = tau, y = pct_acc, colour = pct_acc, fill = pct_acc)) +
  geom_col() +
  scale_colour_viridis_c("Pct. Accept", breaks = seq(0.9, 1, by = 0.05), labels = scales::percent, direction = -1, option = "mako") +
  scale_fill_viridis_c("Pct. Accept", breaks = seq(0.9, 1, by = 0.05), labels = scales::percent, direction = -1, option = "mako") +
  scale_y_continuous(labels = scales::percent) +
  labs(
    x = "Subject",
    y = "Tau Acceptance",
    title = "Subject-specific Regularization Acceptance Rate"
  ) +
  theme(legend.position = "left") +
  coord_flip()
```

```{r tauk_diag_display, eval = FALSE, echo = FALSE, fig.height=6, fig.width=6}
tauk.gg
tauk_acc.gg
result$tau_step %>%
  as.data.frame() %>%
  mutate(tau_step = paste0("Adaptive step ", 1:n())) %>%
  rename_with(
    .cols = everything(),
    ~str_replace(.x, "V", "Subj. ")
  ) %>%
  dplyr::select(tau_step, everything()) %>%
  #rename(`Step Size` = `.`) %>%
  #group_by(tau_step) %>%
  gt() %>%
  tab_header(title = "Adaptive Tau-proposal Step-size/Variance")
```

## 3.3 $\Omega_k$ & $G_k$  

```{r gk_results, fig.height = 8}
#Read in result to display diagnostics
#result <- read_rds("../results/2023_02_08_debug_omegak.RDS")
n_iter <- dim(result$omega_k)[3]
set.seed(4)
roi_samp <- sample(dim(result$omega_k)[1], 20) %>% sort()

#result df
omegak.df <-
  map_df(.x = 1:n_iter,
         ~tibble(iteration = .x, 
                 omega_k   = list(as.data.frame(result$omega_k[,,.x]) %>% mutate(roi = 1:n())))
  ) %>%
  unnest(cols = c(omega_k)) %>%
  rename_with(
    .cols = -iteration,
    ~str_replace(.x, "V", "Sub. ")
  ) %>%
  pivot_longer(
    cols = contains("Sub"),
    names_to = "subject",
    values_to = "value"
  ) 

#ggplot
omegak.gg <-
  omegak.df %>%
  filter(roi %in% roi_samp) %>% #Take a sample for plotting
  mutate(
    Subject = as.factor(subject) %>% fct_reorder(value, mean, .desc = FALSE),
    roi     = as.factor(str_c("ROI Pair ", roi)) %>% fct_reorder(value, mean, .desc = TRUE)
  ) %>%
  ggplot(aes(x = iteration, y = value, colour = Subject)) +
  #geom_point(size = 0.8, alpha = 0.2) +
  geom_line(size = 0.6, alpha = 0.36) +
  facet_wrap(~roi, scales = "free_y", nrow = 2) +
  scale_x_continuous(breaks = seq(0, n_iter, by = floor(1/4*n_iter)), 
                     minor_breaks = seq(0, n_iter, by = floor(1/4*n_iter))) +
  theme(legend.position = "bottom") +
  scale_colour_viridis_d(option = "mako") +
  labs(
    x = "Iteration",
    y = "Value",
    title = "Omega_k Chains by ROI & Subject w/ Fixed Tau_k and Omega_0"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.5))
```

```{r gk_diag}
#Set up null matrix of correct dimension to recover full precision for each Kth subject
p  <- ncol(sim_res$data_list[[1]])

#Function to fill matrix w/upper triangle and make symettric
fill_mat <- function(res_vec, p) {
  null.mat <- matrix(data = 0, nrow = p, ncol = p)
  null.mat[upper.tri(null.mat, diag = TRUE)] <- res_vec
  null_temp.mat <- null.mat
  diag(null_temp.mat) <- 0
  full_precision <- null.mat + t(null_temp.mat)
  return(full_precision)
}

#Process results and summarise
omegak_acc.df <- 
  omegak.df %>%
  group_by(subject, roi) %>%
  summarise(
    post_mean = mean(value),
    post_median = median(value),
    .groups = "drop"
  ) %>%
  nest(result = -c(subject)) %>%
  mutate(
    mean_mat = map(.x = result, ~fill_mat(.x$post_mean, p)),
    med_mat  = map(.x = result, ~fill_mat(.x$post_median, p)),
    truth    = sim_res$true_params$omega_k,
    mean_abs_dif = map2_dbl(.x = mean_mat, .y = truth, ~mean(abs(.x - .y))),
    med_abs_dif  = map2_dbl(.x = med_mat,  .y = truth, ~mean(abs(.x - .y))),
    mean_sq_dif  = map2_dbl(.x = mean_mat,  .y = truth, ~mean((.x - .y)^2)),
    med_sq_dif   = map2_dbl(.x = med_mat,  .y = truth, ~mean((.x - .y)^2)),
  )


#Summary of difference between post-mean/med and original Omega_k's by norm
norm_types <- c("1", "F", "2")
K <- length(unique(omegak_acc.df$subject))

#Create diagnostic plot
omegak_diag.gg <- 
  omegak_acc.df %>%
  dplyr::select(-contains(c("dif", "result"))) %>%
  mutate(
    mean_dif = map2(.x = mean_mat, .y = truth, ~.y - .x),
    med_dif  = map2(.x = med_mat, .y = truth, ~.y - .x)
  ) %>%
  pivot_longer(
    cols = -c(subject),
    names_to  = "precision",
    values_to = "value" 
  ) %>%
  mutate(
    L1_norm   = map_dbl(.x = value, ~norm(.x, type = "1")),
    F_norm    = map_dbl(.x = value, ~norm(.x, type = "F")),
    Spectral_norm = map_dbl(.x = value, ~norm(.x, type = "2")),
    precision = case_when(precision %in% "mean_mat" ~ "Post. Mean",
                          precision %in% "med_mat"  ~ "Post. Median",
                          precision %in% "mean_dif" ~ "Truth - Post. Mean",
                          precision %in% "med_dif"  ~ "Truth - Post. Median",
                          TRUE ~ "Truth") %>%
                as_factor() %>%
                fct_reorder2(L1_norm, F_norm, .desc = TRUE)
  ) %>%
  dplyr::select(-value) %>%
  rename(L1 = L1_norm, Frobenius = F_norm, Spectral = Spectral_norm) %>%
  pivot_longer(
    cols = where(is.numeric),
    names_to = "Norm Type",
    values_to = "value"
  ) %>%
  mutate(subject = str_remove(subject, "Sub. ") %>% as.numeric()) %>%
  ggplot(aes(x = subject, y = value, colour = precision)) +
  geom_line(alpha = 0.8, size = 0.8) +
  geom_point(alpha = 1, size = 2) +
  
  #stat_smooth(alpha = 0.1, se = FALSE, method = "lm") +
  labs(
    x = "Subject",
    y = "Norm Length",
    title = "Subject-specific Network Diagnostics"
  ) +
  scale_colour_viridis_d("Norm Type", option = "mako") +
  facet_wrap(~`Norm Type`) +
  scale_x_continuous(breaks = seq(1, K, by = 2), minor_breaks = seq(1, K, by = 4)) +
 # ggthemes::theme_economist() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
  #theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.5))
```

```{r gk_diag_viz}
#omegak.gg
#omegak_diag.gg
```

# 4. Truth vs. Estimate network diagrams  

```{r omega0_result_pull}
##Precision/Omega
#Take posterior mean/mode as estimates
post_mean  <- apply(result$omega_0, 1, mean)   #L2
post_med   <- apply(result$omega_0, 1, median) #L1

#post_mode  <- apply(result$omega_0, 1, stat_mode) # Need a user defined mode func if so
Omega_0    <- sim_res$true_params$omega_0
Sigma_0    <- sim_res$true_params$omega_0 %>% solve()
omega_true <- Omega_0[upper.tri(Omega_0, diag = TRUE)]

##Variance/Sigma
post_omega0 <- Omega_0 #Just for correct size, going to overwrite
post_omega0[upper.tri(post_omega0, diag = TRUE)]  <- post_mean
post_omega0 <- as.matrix(Matrix::forceSymmetric(post_omega0, uplo = "U"))

#Threshold
#post_omega0 <- ifelse(post_omega0 <= 0.001, 0, post_omega0)
```

```{r omega0_net_viz}
dif_fc.mat <- Omega_0 - post_omega0
min_diff   <- min(dif_fc.mat)
max_diff   <- max(dif_fc.mat)
tidy_x     <- dif_fc.mat %>%
  corrr::as_cordf() %>%
  corrr::stretch(., remove.dups = TRUE) %>%
  filter(abs(r) > 0.001) %>% 
  rename(to = x, from = y, val = r)

#Store vertices from above
vertices <- unique(c(as.character(tidy_x$from), as.character(tidy_x$to)))

#Make vertex.df for plotting labels around circle
vertices.df <- tibble(
  name  = c("origin", vertices),
  id    = c(NA, 1:length(vertices)),
  angle = 90 - 360 * id / length(vertices),
  hjust = ifelse(angle > -90, 0, 1)
) %>%
  mutate(
    angle = ifelse(angle < -90, angle + 180, angle)
  )

#Set up hierarchical/tree graph for geom_conn_bundle (all leaves from "origin")
#needs indices for from-to, hence the match()
hierarchy <- data.frame(from = "origin", to = vertices)
from      <- match(tidy_x$from, vertices.df$name)
to        <- match(tidy_x$to, vertices.df$name)

#Create igraph object (directed for geom_conn_bundle)
my_graph  <- graph_from_data_frame(hierarchy, vertices = vertices.df, directed = TRUE)

#Create colour var for plotting with bundle
col <- tidy_x$val
pad <- 1.6

#Plot the dang thing in a circle with edge bundles and nodes
omega0_difnet.gg <- ggraph(my_graph, layout = 'dendrogram', circular = TRUE) +
  geom_conn_bundle(data    = get_con(from = from, to = to, col = col), 
                   alpha   = 0.6,
                   tension = 0.8,
                   width   = 1.6,
                   aes(colour = col)) +
  geom_node_text(aes(x      = x * 1.08,
                     y      = y * 1.08, 
                     filter = leaf,
                     label  = name,
                     angle  = angle,
                     hjust  = hjust),
                 colour = "grey60",
                 size   = 4, 
                 alpha  = 1,
                 repel  = FALSE) +
  geom_node_point(aes(filter = leaf,
                      x      = x * 1.01, 
                      y      = y * 1.01),
                      colour = "grey60",
                      size   = 4,
                      alpha  = 0.6) +
 # scale_colour_discrete(name = "Key Nodes", type = c("blue", "red", "#F10BF4", "grey60"), ) +
  scale_edge_colour_gradient2(
    name = "FC DIfference", 
    low  = "blue",
    mid  = NA,
    high = "red",
    breaks = c(round(min_diff, 2) + 0.02, 0, round(max_diff, 2) - 0.02),
    ) +
  xlim(-pad, pad) + #Controls size of network for plotting
  ylim(-pad, pad) + #Wider = smaller network, more room for names if long
  labs(
    title    = "Difference between True Group Network and Posterior Mean Est.",
    #subtitle = "" 
  ) +
  theme_void() +
  theme(
    plot.title        = element_text(hjust  = 0.5, margin = margin(c(20, 0, 0, 0), unit = "pt")), 
    plot.subtitle     = element_text(hjust  = 0.5, margin = margin(c(5, 0, 0, 0), unit = "pt")),
    legend.position   = c(0.88, 0.2), 
    legend.box        = "horizonal",
    plot.background  = element_rect(fill = "white", colour = "white"),
    ) 

#Display
omega0_difnet.gg
```

```{r omegak_net_viz}
#Get subject-specific difference
omegak_net_viz.df <-
  omegak_acc.df %>%
  mutate(
    mean_dif = map2(.x = truth, .y = mean_mat, ~.x - .y)
  )

#Take the average of subject specific differences
dif_fc.mat <- Reduce("+", omegak_net_viz.df$mean_dif) / nrow(omegak_acc.df)
min_diff   <- min(dif_fc.mat)
max_diff   <- max(dif_fc.mat)
tidy_x     <- dif_fc.mat %>%
  corrr::as_cordf() %>%
  corrr::stretch(., remove.dups = TRUE) %>%
  filter(abs(r) > 0.001) %>% 
  rename(to = x, from = y, val = r)

#Store vertices from above
vertices <- unique(c(as.character(tidy_x$from), as.character(tidy_x$to)))

#Make vertex.df for plotting labels around circle
vertices.df <- tibble(
  name  = c("origin", vertices),
  id    = c(NA, 1:length(vertices)),
  angle = 90 - 360 * id / length(vertices),
  hjust = ifelse(angle > -90, 0, 1)
) %>%
  mutate(
    angle = ifelse(angle < -90, angle + 180, angle)
  )

#Set up hierarchical/tree graph for geom_conn_bundle (all leaves from "origin")
#needs indices for from-to, hence the match()
hierarchy <- data.frame(from = "origin", to = vertices)
from      <- match(tidy_x$from, vertices.df$name)
to        <- match(tidy_x$to, vertices.df$name)

#Create igraph object (directed for geom_conn_bundle)
my_graph  <- graph_from_data_frame(hierarchy, vertices = vertices.df, directed = TRUE)

#Create colour var for plotting with bundle
col <- tidy_x$val
pad <- 1.6

#Plot the dang thing in a circle with edge bundles and nodes
omegak_difnet.gg <- ggraph(my_graph, layout = 'dendrogram', circular = TRUE) +
  geom_conn_bundle(data    = get_con(from = from, to = to, col = col), 
                   alpha   = 0.6,
                   tension = 0.8,
                   width   = 1.6,
                   aes(colour = col)) +
  geom_node_text(aes(x      = x * 1.08,
                     y      = y * 1.08, 
                     filter = leaf,
                     label  = name,
                     angle  = angle,
                     hjust  = hjust), 
                 colour = "grey60",
                 size   = 4, 
                 alpha  = 1,
                 repel  = FALSE) +
  geom_node_point(aes(filter = leaf,
                      x      = x * 1.01, 
                      y      = y * 1.01),
                      colour = "grey60",
                      size   = 4,
                      alpha  = 0.6) +
 # scale_colour_discrete(name = "Key Nodes", type = c("blue", "red", "#F10BF4", "grey60"), ) +
  scale_edge_colour_gradient2(
    name = "FC DIfference", 
    low  = "blue",
    mid  = NA,
    high = "red",
    breaks = c(round(min_diff, 2) + 0.02, 0, round(max_diff, 2) - 0.02),
    ) +
  xlim(-pad, pad) + #Controls size of network for plotting
  ylim(-pad, pad) + #Wider = smaller network, more room for names if long
  labs(
    title    = "Avg. Difference between True Subject-specific Network and Posterior Mean Est.",
    #subtitle = "" 
  ) +
  theme_void() +
  theme(
    plot.title        = element_text(hjust  = 0.5, margin = margin(c(20, 0, 0, 0), unit = "pt")), 
    plot.subtitle     = element_text(hjust  = 0.5, margin = margin(c(5, 0, 0, 0), unit = "pt")),
    legend.position   = c(0.88, 0.2), 
    legend.box        = "horizonal",
    plot.background  = element_rect(fill = "white", colour = "white"),
    ) 

#Display
omegak_difnet.gg
```

# 5. Write out figures for display  

```{r}
#Create directory for saving figures based on sim inputs
out_path <- str_c("./figures/", name)
dir.create(out_path)

#Save plots that don't need special height width
reg_plots <-
list(
  omegak_difnet = omegak_difnet.gg, #Omegak
  omegak_diag   = omegak_diag.gg,
  omega0_difnet = omega0_difnet.gg, #Omega0
  omega0_acc    = accept0.gg,
  tau_acc       = tauk_acc.gg       #Tau
)

#iterate over list and save with name
map2(.x = reg_plots, .y = names(reg_plots), ~ggsave(plot = .x, filename = str_c(out_path, "/", .y, ".png")))

#Save plots that *do* need special height width
spec_plots <-
list(
  omega0_chain = chain0.gg,       #Omega0
  omega0_postd = post_density.gg,
  tauk_chain    = tauk.gg          #Tau_k
)

#iterate over list and save with name
map2(.x = spec_plots, .y = names(spec_plots), ~ggsave(plot = .x, filename = str_c(out_path, "/", .y, ".png"), height = 8, width = 6))

#Save omegak posterior chain, needs to be bigger than the rest
ggsave(plot = omegak.gg, filename = str_c(out_path, "/omegak_chain.png"), height = 12, width = 8)

#save omega0 norm gt
gtsave(omega0.gt, str_c(out_path, "/omega0_norm.png"), expand = 10)
```

